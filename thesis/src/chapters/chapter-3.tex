\chapter{vLab Overview}
\label{chapter:Chapter 3}

% \todo{* o descriere din punct de vedere al utilizatorului (user workflow)
%* diagrame UML (diagrame de interactiune)
%* ce se intampla in spate (dar la nivel general) cand adaugi un host,
%un switch etc.
%* momentan facem configurile de mana (avem niste default-uri) insa
%utilizatorul poate
%folosi o interfata grafica (MiniEdit) deja existenta pentru a crea configuratii.
%}

This chapter aims to provide a broad view of the \project\ application in terms of how the user can interact with it, what are the main use cases and how it works in general.
The focus is on who can use \project\ and what can one do with the application, namely what are the main use cases for it.
Then, a short description about what actually happens in the back-end is made for the user to better understand the workflow.

\section{Who Uses \project?}
\label{sec:who-uses-vlab}

Basically anyone can use \project, given the fact that it is an open source project and it's freely available.
Even though this is true, not everybody will end up needing this tool because it is specialized for tasks related to networking and kernel modules testing in general.
A developer needs to use his time as efficiently as possible, thus he needs to automate every job that he can.
It is pretty difficult to check whether the module under test is full of bugs or not without the possibility to automate things, especially when developing kernel modules.

Taking these facts into consideration, there are several use cases for \project\ discussed next.

\abbrev{VM}{Virtual Machine}
\subsection{Turning On or Off the VMs}
\label{sub-sec:turning-on-off-vms}

\fig[scale=1]{src/img/diagrams/usecase-start-stop.pdf}{img:usecase-start-stop}{Starting/Stopping VMs Usecase Diagram}

This scenario presents the user who normally needs to start or stop the Virtual Machines that he needs for testing.
It is exactly what \labelindexref{Figure}{img:usecase-start-stop} expresses, having the developer centered on either trying to turn the environment on and then doing some other tasks like testing or running debugging command and then stopping it when he's done.
He can either start or stop every Virtual Machine, which in \project\ are referred to as Hosts, or he can choose which one to turn on or off individually, in separate commands.
This first case would be the preferred one for automated testing, while the latter would only be used for debugging purposes, let's say one would need to start only some machines from a given network topology and then run debugging commands like \texttt{tcpdump} to check only that part in the topology.

Of course, the application is designed such that the user cannot accidentally start the Virtual Machines if they are already started, or in the process to be turned on, as well as for the process of turning them off.
This behavior not only easier to implement and test, but it is also the best choice in this case, as it guarantees that the hosts corresponding to the topology can be started once and only once, which in fact means the number of states in which the application can be at some point is deterministic.

\subsection{Spawning an Xterm Session on Each VM}
\label{sub-sec:spawn-xterm}

\fig[scale=1]{src/img/diagrams/usecase-spawn-xterm.pdf}{img:usecase-spawn-xterm}{Spawning a New Xterm Session}

Another use case is presented in \labelindexref{Figure}{img:usecase-spawn-xterm}, which describe how the user can spawn Xterm sessions for each machine.
This is a handy feature when the user needs to quickly get access to some, or all VMs at once.
Basically once starting an Xterm session on a VM, the user has full access to that machine, such that he can easily view its state through different commands available on any Linux based operating system.

Also, the user has the possibility to open several Xterm sessions on the same VM, such that he can do some tests that involve using two or more terminals to be opened at a time.

\subsection{Running commands on VMs}
\label{sub-sec:run-cmd}

\fig[scale=1]{src/img/diagrams/usecase-run-cmd.pdf}{img:usecase-run-cmd}{Running a command on VMs}

Besides spawning Xterm sessions to control the Hosts, the user also has the option to send commands directly through \project\ CLI.
This use case, described in \labelindexref{Figure}{img:usecase-run-cmd}, offers another simple way for quick sending commands to Hosts, without the need to actually connect to them via SSH or Xterm sessions.
The feature is similar to the way Mininet handles the sending of commands to hosts, being able to write something like this:

\lstset{label=lst:ping-example}
\begin{lstlisting}
vLab> host1 ping host2
\end{lstlisting}

This creates a connection to the machine named \texttt{host1} and runs the command \texttt{ping host2} in the context of the host1 machine, printing the output of the command on \project\ CLI.
It basically redirects standard error and standard output to \project\ CLI such that the user can see whether he issued a wrong command, or there was an error when running the actual command.

\section{Typical workflow in \project}
\label{sec:typical-workflow}

This section presents how actions are linked one to another in \project.
They are shown graphically in \labelindexref{Figure}{img:activity-overview} for a better understanding.

\fig[scale=0.8]{src/img/diagrams/activity-overview.pdf}{img:activity-overview}{Activity diagram overview}

The entry point of the activity diagram is when the user actually starts the application.
Further on, the application waits for commands from the user.
This basically replaces the current terminal where \project\ is run with the internal CLI defined within the application.
This CLI is responsible for waiting for any input from the user, and then passing the command to the rest of the application.
The fastest way to get to the final point is to enter the command for terminating the application, which has a couple aliases described in \labelindexref{Chapter}{chapter:Chapter 4}.

The other main paths through the application are represented by the commands for starting and stopping the Virtual Machines.
There is a command that can start every host at once, or another which starts only one host given its hostname.
While the machines are in the process to be started, the user cannot issue any other new commands, as they would need to be turned on anyway for being able to receive the commands.
Before actually trying to start a machine, the application verifies whether it was already turned on or not.
The counterpart of the start command is of course, the stop one, which does the reverse.

Any other command is simply executed and then the output is printed to the console where the CLI is run.
These kind of instructions represent the part where the user can begin running tests, or do whatever he wants with any of the machines that he just spawned.

\section{Hosts and topologies}
\label{sec:hosts-and-topologies}


