\chapter{vLab Overview}
\label{chapter:Chapter 3}

% \todo{* o descriere din punct de vedere al utilizatorului (user workflow)
%* diagrame UML (diagrame de interactiune)
%* ce se intampla in spate (dar la nivel general) cand adaugi un host,
%un switch etc.
%* momentan facem configurile de mana (avem niste default-uri) insa
%utilizatorul poate
%folosi o interfata grafica (MiniEdit) deja existenta pentru a crea configuratii.
%}

This chapter aims to provide a broad view of the \project\ application in terms of how the user can interact with it, what are the main use cases and how it works in general.
The focus is on who can use \project\ and what can one do with the application, namely what are the main use cases for it.
Then, a short description about what actually happens in the back-end is made for the user to better understand the workflow.

\section{Who Uses \project?}
\label{sec:who-uses-vlab}

Basically anyone can use \project, given the fact that it is an open source project and it's freely available.
Even though this is true, not everybody will end up needing this tool because it is specialized for tasks related to networking and kernel modules testing in general.
A developer needs to use his time as efficiently as possible, thus he needs to automate every job that he can.
It is pretty difficult to check whether the module under test is full of bugs or not without the possibility to automate things, especially when developing kernel modules.

Taking these facts into consideration, there are several use cases for \project\ discussed next.

\abbrev{VM}{Virtual Machine}
\subsection{Turning On or Off the VMs}
\label{sub-sec:turning-on-off-vms}

\fig[scale=1]{src/img/diagrams/usecase-start-stop.pdf}{img:usecase-start-stop}{Starting/Stopping VMs Usecase Diagram}

This scenario presents the user who normally needs to start or stop the Virtual Machines that he needs for testing.
It is exactly what \labelindexref{Figure}{img:usecase-start-stop} expresses, having the developer centered on either trying to turn the environment on and then doing some other tasks like testing or running debugging command and then stopping it when he's done.
He can either start or stop every Virtual Machine, which in \project\ are referred to as Hosts, or he can choose which one to turn on or off individually, in separate commands.
This first case would be the preferred one for automated testing, while the latter would only be used for debugging purposes, let's say one would need to start only some machines from a given network topology and then run debugging commands like \texttt{tcpdump} to check only that part in the topology.

Of course, the application is designed such that the user cannot accidentally start the Virtual Machines if they are already started, or in the process to be turned on, as well as for the process of turning them off.
This behavior not only easier to implement and test, but it is also the best choice in this case, as it guarantees that the hosts corresponding to the topology can be started once and only once, which in fact means the number of states in which the application can be at some point is deterministic.

\subsection{Spawning an Xterm Session on Each VM}
\label{sub-sec:spawn-xterm}

\fig[scale=1]{src/img/diagrams/usecase-spawn-xterm.pdf}{img:usecase-spawn-xterm}{Spawning a New Xterm Session}

Another use case is presented in \labelindexref{Figure}{img:usecase-spawn-xterm}, which describe how the user can spawn Xterm sessions for each machine.
This is a handy feature when the user needs to quickly get access to some, or all VMs at once.
Basically once starting an Xterm session on a VM, the user has full access to that machine, such that he can easily view its state through different commands available on any Linux based operating system.

Also, the user has the possibility to open several Xterm sessions on the same VM, such that he can do some tests that involve using two or more terminals to be opened at a time.

\subsection{Running commands on VMs}
\label{sub-sec:run-cmd}

\fig[scale=1]{src/img/diagrams/usecase-run-cmd.pdf}{img:usecase-run-cmd}{Running a command on VMs}

Besides spawning Xterm sessions to control the Hosts, the user also has the option to send commands directly through \project\ CLI.
This use case, described in \labelindexref{Figure}{img:usecase-run-cmd}, offers another simple way for quick sending commands to Hosts, without the need to actually connect to them via SSH or Xterm sessions.
The feature is similar to the way Mininet handles the sending of commands to hosts, being able to write something like this:

\lstset{label=lst:ping-example}
\begin{lstlisting}
vLab> host1 ping host2
\end{lstlisting}

This creates a connection to the machine named \texttt{host1} and runs the command \texttt{ping host2} in the context of the host1 machine, printing the output of the command on \project\ CLI.
It basically redirects standard error and standard output to \project\ CLI such that the user can see whether he issued a wrong command, or there was an error when running the actual command.

\section{Typical User Activities in \project}

\fig[scale=0.8]{src/img/diagrams/activity-overview.pdf}{img:activity-overview}{Activity diagram overview}

We have now included \labelindexref{Figure}{img:activity-overview}.

TODO
